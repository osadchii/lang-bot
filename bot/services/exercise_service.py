"""Exercise service for grammar practice sessions."""

import json
import random
from dataclasses import dataclass
from enum import Enum

from openai import APIConnectionError, APIError, APITimeoutError, AsyncOpenAI, RateLimitError
from sqlalchemy.ext.asyncio import AsyncSession

from bot.config.logging_config import get_logger
from bot.config.settings import settings
from bot.database.repositories.card_repo import CardRepository
from bot.database.repositories.deck_repo import DeckRepository

logger = get_logger(__name__)


class ExerciseType(str, Enum):
    """Types of grammar exercises."""

    TENSES = "tenses"
    CONJUGATIONS = "conjugations"
    CASES = "cases"


@dataclass
class ExerciseTask:
    """A single exercise task."""

    word: str  # Greek word
    translation: str  # Russian translation
    task_text: str  # Task description in Russian
    task_hint: str  # Grammar hint (e.g., "Aoristos")
    expected_answer: str  # Correct answer
    is_from_ai: bool  # Whether word was generated by AI


@dataclass
class AnswerResult:
    """Result of answer verification."""

    is_correct: bool
    feedback: str  # Grammar explanation in Russian
    correct_answer: str  # Show correct answer if wrong


class ExerciseService:
    """Service for grammar exercise sessions."""

    def __init__(self, session: AsyncSession):
        """Initialize exercise service.

        Args:
            session: Async database session
        """
        self.session = session
        self.card_repo = CardRepository(session)
        self.deck_repo = DeckRepository(session)
        self.client = AsyncOpenAI(
            api_key=settings.openai_api_key,
            timeout=settings.openai_timeout,
        )
        self.model = settings.openai_model

    async def get_user_words_for_exercise(
        self,
        user_id: int,
        exercise_type: ExerciseType,
        limit: int = 50,
    ) -> list[dict]:
        """Get words from user's cards suitable for the exercise type.

        Args:
            user_id: User ID
            exercise_type: Type of exercise
            limit: Maximum words to fetch

        Returns:
            List of dicts with 'word' and 'translation' keys
        """
        # Get all user's decks
        decks = await self.deck_repo.get_user_decks(user_id)
        if not decks:
            return []

        words = []

        # Collect words from cards
        for deck in decks:
            cards = await self.card_repo.get_deck_cards(deck.id, limit=limit)
            for card in cards:
                # Filter by exercise type
                if exercise_type == ExerciseType.CASES:
                    # For cases, need nouns (words with articles)
                    if self._is_noun(card.front):
                        words.append(
                            {
                                "word": card.front,
                                "translation": card.back,
                            }
                        )
                else:
                    # For tenses/conjugations, need verbs
                    if self._is_verb(card.front):
                        words.append(
                            {
                                "word": card.front,
                                "translation": card.back,
                            }
                        )

        return words[:limit]

    def _is_noun(self, word: str) -> bool:
        """Check if word appears to be a noun (has article).

        Args:
            word: Greek word

        Returns:
            True if likely a noun
        """
        articles = ["ο ", "η ", "το ", "οι ", "τα "]
        word_lower = word.lower().strip()
        return any(word_lower.startswith(art) for art in articles)

    def _is_verb(self, word: str) -> bool:
        """Check if word appears to be a verb (ends in common verb endings).

        Args:
            word: Greek word

        Returns:
            True if likely a verb
        """
        # Verbs typically end in -ω, -ώ, -αω, -ιω, etc.
        verb_endings = ["ω", "ώ", "ει", "αι", "ουν", "ουμε"]
        word_stripped = word.strip()
        return any(word_stripped.endswith(ending) for ending in verb_endings)

    async def generate_task(
        self,
        exercise_type: ExerciseType,
        user_words: list[dict] | None = None,
    ) -> ExerciseTask:
        """Generate an exercise task.

        First tries to use user's words, falls back to AI generation.

        Args:
            exercise_type: Type of exercise
            user_words: Optional list of user's words

        Returns:
            ExerciseTask with task details
        """
        # Try to use user's word first
        if user_words:
            word_data = random.choice(user_words)
            is_from_ai = False
        else:
            # Generate word with AI
            word_data = await self._generate_word_with_ai(exercise_type)
            is_from_ai = True

        # Generate the specific task based on type
        task = await self._generate_task_details(
            exercise_type=exercise_type,
            word=word_data["word"],
            translation=word_data["translation"],
            is_from_ai=is_from_ai,
        )

        return task

    async def _generate_word_with_ai(
        self,
        exercise_type: ExerciseType,
    ) -> dict:
        """Generate a word using AI.

        Args:
            exercise_type: Type of exercise

        Returns:
            Dict with 'word' and 'translation'
        """
        if exercise_type == ExerciseType.CASES:
            word_type = "noun with definite article (o/η/το)"
            examples = "o ανθρωπος, η γυναικα, το παιδι"
        else:
            word_type = "common verb in present tense 1st person singular"
            examples = "γραφω, διαβαζω, τρωω, πινω"

        prompt = f"""Generate a random Greek {word_type} for a language learning exercise.

Requirements:
- Choose a common, frequently used word
- Suitable for A1-B1 learners
- Examples of format: {examples}

Respond in JSON format:
{{
    "word": "Greek word",
    "translation": "Russian translation"
}}"""

        try:
            response = await self.client.chat.completions.create(
                model=self.model,
                messages=[
                    {
                        "role": "system",
                        "content": (
                            "You are a Greek language tutor. Generate words for exercises. "
                            "Respond only in valid JSON."
                        ),
                    },
                    {"role": "user", "content": prompt},
                ],
                max_tokens=100,
                temperature=0.8,
                response_format={"type": "json_object"},
            )

            content = response.choices[0].message.content or "{}"
            data = json.loads(content)

            return {
                "word": data.get("word", "γραφω"),
                "translation": data.get("translation", "писать"),
            }
        except (RateLimitError, APITimeoutError, APIConnectionError, APIError) as e:
            logger.error(f"AI word generation error: {e}")
            # Fallback words
            if exercise_type == ExerciseType.CASES:
                return {"word": "ο ανθρωπος", "translation": "человек"}
            return {"word": "γραφω", "translation": "писать"}
        except Exception as e:
            logger.exception(f"Unexpected error in word generation: {e}")
            if exercise_type == ExerciseType.CASES:
                return {"word": "ο ανθρωπος", "translation": "человек"}
            return {"word": "γραφω", "translation": "писать"}

    async def _generate_task_details(
        self,
        exercise_type: ExerciseType,
        word: str,
        translation: str,
        is_from_ai: bool,
    ) -> ExerciseTask:
        """Generate task details including the expected answer.

        Args:
            exercise_type: Type of exercise
            word: Greek word
            translation: Russian translation
            is_from_ai: Whether word is AI-generated

        Returns:
            Complete ExerciseTask
        """
        if exercise_type == ExerciseType.TENSES:
            return await self._generate_tense_task(word, translation, is_from_ai)
        elif exercise_type == ExerciseType.CONJUGATIONS:
            return await self._generate_conjugation_task(word, translation, is_from_ai)
        else:  # CASES
            return await self._generate_case_task(word, translation, is_from_ai)

    async def _generate_tense_task(
        self,
        word: str,
        translation: str,
        is_from_ai: bool,
    ) -> ExerciseTask:
        """Generate a tense exercise task.

        Args:
            word: Greek verb
            translation: Russian translation
            is_from_ai: Whether word is AI-generated

        Returns:
            ExerciseTask for tense practice
        """
        tenses = [
            ("Ενεστωτας", "настоящее время"),
            ("Αοριστος", "прошедшее время (аорист)"),
            ("Μελλοντας", "будущее время"),
        ]
        tense_greek, tense_russian = random.choice(tenses)

        prompt = f"""For the Greek verb "{word}" ({translation}), provide the correct form in {tense_greek} (1st person singular).

Respond in JSON:
{{
    "correct_form": "the verb in requested tense"
}}"""

        try:
            response = await self.client.chat.completions.create(
                model=self.model,
                messages=[
                    {
                        "role": "system",
                        "content": "You are a Greek grammar expert. Provide accurate verb conjugations.",
                    },
                    {"role": "user", "content": prompt},
                ],
                max_tokens=50,
                temperature=0.2,
                response_format={"type": "json_object"},
            )

            content = response.choices[0].message.content or "{}"
            data = json.loads(content)
            expected_answer = data.get("correct_form", word)
        except (RateLimitError, APITimeoutError, APIConnectionError, APIError) as e:
            logger.error(f"Tense task generation API error: {e}")
            expected_answer = word
        except Exception as e:
            logger.exception(f"Unexpected error in tense task generation: {e}")
            expected_answer = word

        return ExerciseTask(
            word=word,
            translation=translation,
            task_text=f"Поставь глагол в {tense_russian}",
            task_hint=tense_greek,
            expected_answer=expected_answer,
            is_from_ai=is_from_ai,
        )

    async def _generate_conjugation_task(
        self,
        word: str,
        translation: str,
        is_from_ai: bool,
    ) -> ExerciseTask:
        """Generate a conjugation exercise task.

        Args:
            word: Greek verb
            translation: Russian translation
            is_from_ai: Whether word is AI-generated

        Returns:
            ExerciseTask for conjugation practice
        """
        persons = [
            ("1st_singular", "εγω", "1-е лицо ед.ч. (εγω)"),
            ("2nd_singular", "εσυ", "2-е лицо ед.ч. (εσυ)"),
            ("3rd_singular", "αυτος", "3-е лицо ед.ч. (αυτος/η/ο)"),
            ("1st_plural", "εμεις", "1-е лицо мн.ч. (εμεις)"),
            ("2nd_plural", "εσεις", "2-е лицо мн.ч. (εσεις)"),
            ("3rd_plural", "αυτοι", "3-е лицо мн.ч. (αυτοι/ες/α)"),
        ]
        person_id, pronoun, person_russian = random.choice(persons)

        prompt = f"""For the Greek verb "{word}" ({translation}), provide the correct form for {person_id} ({pronoun}) in present tense.

Respond in JSON:
{{
    "correct_form": "the conjugated verb"
}}"""

        try:
            response = await self.client.chat.completions.create(
                model=self.model,
                messages=[
                    {
                        "role": "system",
                        "content": "You are a Greek grammar expert. Provide accurate verb conjugations.",
                    },
                    {"role": "user", "content": prompt},
                ],
                max_tokens=50,
                temperature=0.2,
                response_format={"type": "json_object"},
            )

            content = response.choices[0].message.content or "{}"
            data = json.loads(content)
            expected_answer = data.get("correct_form", word)
        except (RateLimitError, APITimeoutError, APIConnectionError, APIError) as e:
            logger.error(f"Conjugation task generation API error: {e}")
            expected_answer = word
        except Exception as e:
            logger.exception(f"Unexpected error in conjugation task generation: {e}")
            expected_answer = word

        return ExerciseTask(
            word=word,
            translation=translation,
            task_text=f"Спрягай для {person_russian}",
            task_hint=pronoun,
            expected_answer=expected_answer,
            is_from_ai=is_from_ai,
        )

    async def _generate_case_task(
        self,
        word: str,
        translation: str,
        is_from_ai: bool,
    ) -> ExerciseTask:
        """Generate a case exercise task.

        Args:
            word: Greek noun with article
            translation: Russian translation
            is_from_ai: Whether word is AI-generated

        Returns:
            ExerciseTask for case practice
        """
        cases = [
            ("Ονομαστικη", "именительный падеж (Ονομαστικη)"),
            ("Γενικη", "родительный падеж (Γενικη)"),
            ("Αιτιατικη", "винительный падеж (Αιτιατικη)"),
            ("Κλητικη", "звательный падеж (Κλητικη)"),
        ]
        case_greek, case_russian = random.choice(cases)

        prompt = f"""For the Greek noun "{word}" ({translation}), provide the correct form in {case_greek} (singular, with article if applicable).

Respond in JSON:
{{
    "correct_form": "the noun in requested case with article"
}}"""

        try:
            response = await self.client.chat.completions.create(
                model=self.model,
                messages=[
                    {
                        "role": "system",
                        "content": (
                            "You are a Greek grammar expert. "
                            "Provide accurate noun declensions with articles."
                        ),
                    },
                    {"role": "user", "content": prompt},
                ],
                max_tokens=50,
                temperature=0.2,
                response_format={"type": "json_object"},
            )

            content = response.choices[0].message.content or "{}"
            data = json.loads(content)
            expected_answer = data.get("correct_form", word)
        except (RateLimitError, APITimeoutError, APIConnectionError, APIError) as e:
            logger.error(f"Case task generation API error: {e}")
            expected_answer = word
        except Exception as e:
            logger.exception(f"Unexpected error in case task generation: {e}")
            expected_answer = word

        return ExerciseTask(
            word=word,
            translation=translation,
            task_text=f"Поставь в {case_russian}",
            task_hint=case_greek,
            expected_answer=expected_answer,
            is_from_ai=is_from_ai,
        )

    async def verify_answer(
        self,
        task: ExerciseTask,
        user_answer: str,
        exercise_type: ExerciseType,
    ) -> AnswerResult:
        """Verify user's answer and provide feedback.

        Args:
            task: The exercise task
            user_answer: User's answer
            exercise_type: Type of exercise

        Returns:
            AnswerResult with correctness and feedback
        """
        prompt = f"""Evaluate the student's answer for a Greek grammar exercise.

Exercise type: {exercise_type.value}
Original word: {task.word} ({task.translation})
Task: {task.task_text} ({task.task_hint})
Expected answer: {task.expected_answer}
Student's answer: {user_answer}

Evaluate if the answer is correct. Consider minor spelling variations and accents.
Provide a brief grammar explanation in Russian.

Respond in JSON:
{{
    "is_correct": true/false,
    "feedback": "Explanation in Russian about the grammar rule and why the answer is correct/incorrect"
}}"""

        try:
            response = await self.client.chat.completions.create(
                model=self.model,
                messages=[
                    {
                        "role": "system",
                        "content": (
                            "You are a Greek language teacher evaluating student answers. "
                            "Be encouraging but accurate. Explain grammar rules simply. "
                            "Respond in Russian for the feedback. Always respond in valid JSON."
                        ),
                    },
                    {"role": "user", "content": prompt},
                ],
                max_tokens=300,
                temperature=0.3,
                response_format={"type": "json_object"},
            )

            content = response.choices[0].message.content or "{}"
            data = json.loads(content)

            return AnswerResult(
                is_correct=data.get("is_correct", False),
                feedback=data.get("feedback", ""),
                correct_answer=task.expected_answer,
            )
        except (RateLimitError, APITimeoutError, APIConnectionError, APIError) as e:
            logger.error(f"AI answer verification error: {e}")
            # Simple comparison fallback
            is_correct = user_answer.strip().lower() == task.expected_answer.strip().lower()
            return AnswerResult(
                is_correct=is_correct,
                feedback="Не удалось получить подробную обратную связь.",
                correct_answer=task.expected_answer,
            )
        except Exception as e:
            logger.exception(f"Unexpected error in answer verification: {e}")
            is_correct = user_answer.strip().lower() == task.expected_answer.strip().lower()
            return AnswerResult(
                is_correct=is_correct,
                feedback="Не удалось получить подробную обратную связь.",
                correct_answer=task.expected_answer,
            )
