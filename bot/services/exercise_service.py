"""Exercise service for grammar practice sessions."""

import json
import random
from dataclasses import dataclass
from enum import Enum

from openai import APIConnectionError, APIError, APITimeoutError, AsyncOpenAI, RateLimitError
from sqlalchemy.ext.asyncio import AsyncSession

from bot.config.logging_config import get_logger
from bot.config.settings import settings
from bot.database.repositories.card_repo import CardRepository
from bot.database.repositories.deck_repo import DeckRepository

logger = get_logger(__name__)

# Maximum number of recent (word, variation) combinations to track for variety
MAX_EXERCISE_HISTORY = 10

# Minimum number of words needed for good exercise variety
MIN_WORDS_FOR_VARIETY = 3

# Number of AI words to generate when below threshold
AI_SUPPLEMENT_COUNT = 2


class ExerciseType(str, Enum):
    """Types of grammar exercises."""

    TENSES = "tenses"
    CONJUGATIONS = "conjugations"
    CASES = "cases"


@dataclass
class ExerciseTask:
    """A single exercise task."""

    word: str  # Greek word
    translation: str  # Russian translation
    task_text: str  # Task description in Russian
    task_hint: str  # Grammar hint (e.g., "Aoristos")
    expected_answer: str  # Correct answer
    is_from_ai: bool  # Whether word was generated by AI


@dataclass
class AnswerResult:
    """Result of answer verification."""

    is_correct: bool
    feedback: str  # Grammar explanation in Russian
    correct_answer: str  # Show correct answer if wrong


class ExerciseService:
    """Service for grammar exercise sessions."""

    def __init__(self, session: AsyncSession):
        """Initialize exercise service.

        Args:
            session: Async database session
        """
        self.session = session
        self.card_repo = CardRepository(session)
        self.deck_repo = DeckRepository(session)
        self.client = AsyncOpenAI(
            api_key=settings.openai_api_key,
            timeout=settings.openai_timeout,
        )
        self.model = settings.openai_model

    async def get_user_words_for_exercise(
        self,
        user_id: int,
        exercise_type: ExerciseType,
        limit: int = 50,
    ) -> list[dict]:
        """Get words from user's cards suitable for the exercise type.

        Args:
            user_id: User ID
            exercise_type: Type of exercise
            limit: Maximum words to fetch

        Returns:
            List of dicts with 'word' and 'translation' keys
        """
        # Get all user's decks
        decks = await self.deck_repo.get_user_decks(user_id)
        if not decks:
            return []

        words = []

        # Collect words from cards
        for deck in decks:
            cards = await self.card_repo.get_deck_cards(deck.id, limit=limit)
            for card in cards:
                # Filter by exercise type
                if exercise_type == ExerciseType.CASES:
                    # For cases, need nouns (words with articles)
                    if self._is_noun(card.front):
                        words.append(
                            {
                                "word": card.front,
                                "translation": card.back,
                            }
                        )
                else:
                    # For tenses/conjugations, need verbs
                    if self._is_verb(card.front):
                        words.append(
                            {
                                "word": card.front,
                                "translation": card.back,
                            }
                        )

        return words[:limit]

    def _is_noun(self, word: str) -> bool:
        """Check if word appears to be a noun (has article).

        Args:
            word: Greek word

        Returns:
            True if likely a noun
        """
        articles = ["ο ", "η ", "το ", "οι ", "τα "]
        word_lower = word.lower().strip()
        return any(word_lower.startswith(art) for art in articles)

    def _is_verb(self, word: str) -> bool:
        """Check if word appears to be a verb (ends in common verb endings).

        Args:
            word: Greek word

        Returns:
            True if likely a verb
        """
        # Verbs typically end in -ω, -ώ, -αω, -ιω, etc.
        verb_endings = ["ω", "ώ", "ει", "αι", "ουν", "ουμε"]
        word_stripped = word.strip()
        return any(word_stripped.endswith(ending) for ending in verb_endings)

    def _get_variations_for_type(self, exercise_type: ExerciseType) -> list[tuple]:
        """Get available variations for exercise type, excluding source forms.

        Args:
            exercise_type: Type of exercise

        Returns:
            List of variation tuples
        """
        if exercise_type == ExerciseType.TENSES:
            # Exclude present tense (source form)
            return [
                ("Αοριστος", "прошедшее время (аорист)"),
                ("Μελλοντας", "будущее время"),
            ]
        elif exercise_type == ExerciseType.CONJUGATIONS:
            # Exclude 1st person singular (source form)
            return [
                ("2nd_singular", "εσυ", "2-е лицо ед.ч. (εσυ)"),
                ("3rd_singular", "αυτος", "3-е лицо ед.ч. (αυτος/η/ο)"),
                ("1st_plural", "εμεις", "1-е лицо мн.ч. (εμεις)"),
                ("2nd_plural", "εσεις", "2-е лицо мн.ч. (εσεις)"),
                ("3rd_plural", "αυτοι", "3-е лицо мн.ч. (αυτοι/ες/α)"),
            ]
        else:  # CASES
            # Exclude nominative case (source form)
            return [
                ("Γενικη", "родительный падеж (Γενικη)"),
                ("Αιτιατικη", "винительный падеж (Αιτιατικη)"),
                ("Κλητικη", "звательный падеж (Κλητικη)"),
            ]

    def _select_word_and_variation(
        self,
        words: list[dict],
        variations: list[tuple],
        history: list[tuple[str, str]],
    ) -> tuple[dict, tuple, list[tuple[str, str]]]:
        """Select word and variation avoiding recent combinations.

        Args:
            words: Available words (dicts with 'word' and 'translation')
            variations: Available variations (tuples with key as first element)
            history: List of (word, variation_key) tuples

        Returns:
            (selected_word, selected_variation, updated_history)
        """
        recent_set = set(history[-MAX_EXERCISE_HISTORY:])

        # Build available combinations not in recent history
        available = []
        for word in words:
            word_key = word["word"]
            for variation in variations:
                variation_key = variation[0]
                if (word_key, variation_key) not in recent_set:
                    available.append((word, variation))

        # Fallback if all combinations are in history
        if not available:
            available = [(word, var) for word in words for var in variations]

        selected_word, selected_variation = random.choice(available)

        # Update history
        new_history = history + [(selected_word["word"], selected_variation[0])]
        if len(new_history) > MAX_EXERCISE_HISTORY:
            new_history = new_history[-MAX_EXERCISE_HISTORY:]

        return selected_word, selected_variation, new_history

    async def get_words_with_ai_supplement(
        self,
        user_id: int,
        exercise_type: ExerciseType,
    ) -> tuple[list[dict], list[dict]]:
        """Get words for exercises, supplementing with AI if needed.

        Args:
            user_id: User ID
            exercise_type: Type of exercise

        Returns:
            (all_words, ai_generated_words)
        """
        user_words = await self.get_user_words_for_exercise(
            user_id=user_id,
            exercise_type=exercise_type,
        )

        ai_words: list[dict] = []
        existing_word_texts = {w["word"] for w in user_words}

        if len(user_words) < MIN_WORDS_FOR_VARIETY:
            needed = min(AI_SUPPLEMENT_COUNT, MIN_WORDS_FOR_VARIETY - len(user_words))
            attempts = 0
            max_attempts = needed * 2  # Allow retries for duplicates

            while len(ai_words) < needed and attempts < max_attempts:
                attempts += 1
                ai_word = await self._generate_word_with_ai(exercise_type)
                if ai_word["word"] not in existing_word_texts:
                    ai_words.append(ai_word)
                    existing_word_texts.add(ai_word["word"])

        return user_words + ai_words, ai_words

    async def generate_task(
        self,
        exercise_type: ExerciseType,
        user_words: list[dict] | None = None,
        history: list[tuple[str, str]] | None = None,
    ) -> tuple[ExerciseTask, list[tuple[str, str]]]:
        """Generate an exercise task with history tracking.

        First tries to use user's words with history-aware selection,
        falls back to AI generation.

        Args:
            exercise_type: Type of exercise
            user_words: Optional list of user's words
            history: Optional list of recent (word, variation) combinations

        Returns:
            Tuple of (ExerciseTask, updated_history)
        """
        history = history or []
        variations = self._get_variations_for_type(exercise_type)

        # Try to use user's word first with history-aware selection
        if user_words:
            word_data, selected_variation, new_history = self._select_word_and_variation(
                words=user_words,
                variations=variations,
                history=history,
            )
            is_from_ai = False
        else:
            # Generate word with AI
            word_data = await self._generate_word_with_ai(exercise_type)
            selected_variation = random.choice(variations)
            new_history = history + [(word_data["word"], selected_variation[0])]
            if len(new_history) > MAX_EXERCISE_HISTORY:
                new_history = new_history[-MAX_EXERCISE_HISTORY:]
            is_from_ai = True

        # Generate the specific task based on type with pre-selected variation
        task = await self._generate_task_with_variation(
            exercise_type=exercise_type,
            word=word_data["word"],
            translation=word_data["translation"],
            is_from_ai=is_from_ai,
            variation=selected_variation,
        )

        return task, new_history

    async def _generate_word_with_ai(
        self,
        exercise_type: ExerciseType,
    ) -> dict:
        """Generate a word using AI.

        Args:
            exercise_type: Type of exercise

        Returns:
            Dict with 'word' and 'translation'
        """
        if exercise_type == ExerciseType.CASES:
            word_type = "noun with definite article (o/η/το)"
            examples = "o ανθρωπος, η γυναικα, το παιδι"
        else:
            word_type = "common verb in present tense 1st person singular"
            examples = "γραφω, διαβαζω, τρωω, πινω"

        prompt = f"""Generate a random Greek {word_type} for a language learning exercise.

Requirements:
- Choose a common, frequently used word
- Suitable for A1-B1 learners
- Examples of format: {examples}

Respond in JSON format:
{{
    "word": "Greek word",
    "translation": "Russian translation"
}}"""

        try:
            response = await self.client.chat.completions.create(
                model=self.model,
                messages=[
                    {
                        "role": "system",
                        "content": (
                            "You are a Greek language tutor. Generate words for exercises. "
                            "Respond only in valid JSON."
                        ),
                    },
                    {"role": "user", "content": prompt},
                ],
                max_tokens=100,
                temperature=0.8,
                response_format={"type": "json_object"},
            )

            content = response.choices[0].message.content or "{}"
            data = json.loads(content)

            return {
                "word": data.get("word", "γραφω"),
                "translation": data.get("translation", "писать"),
            }
        except (RateLimitError, APITimeoutError, APIConnectionError, APIError) as e:
            logger.error(f"AI word generation error: {e}")
            # Fallback words
            if exercise_type == ExerciseType.CASES:
                return {"word": "ο ανθρωπος", "translation": "человек"}
            return {"word": "γραφω", "translation": "писать"}
        except Exception as e:
            logger.exception(f"Unexpected error in word generation: {e}")
            if exercise_type == ExerciseType.CASES:
                return {"word": "ο ανθρωπος", "translation": "человек"}
            return {"word": "γραφω", "translation": "писать"}

    async def _generate_task_with_variation(
        self,
        exercise_type: ExerciseType,
        word: str,
        translation: str,
        is_from_ai: bool,
        variation: tuple,
    ) -> ExerciseTask:
        """Generate task details with a pre-selected variation.

        Args:
            exercise_type: Type of exercise
            word: Greek word
            translation: Russian translation
            is_from_ai: Whether word is AI-generated
            variation: Pre-selected variation tuple

        Returns:
            Complete ExerciseTask
        """
        if exercise_type == ExerciseType.TENSES:
            return await self._generate_tense_task(
                word, translation, is_from_ai, selected_tense=variation
            )
        elif exercise_type == ExerciseType.CONJUGATIONS:
            return await self._generate_conjugation_task(
                word, translation, is_from_ai, selected_person=variation
            )
        else:  # CASES
            return await self._generate_case_task(
                word, translation, is_from_ai, selected_case=variation
            )

    async def _generate_tense_task(
        self,
        word: str,
        translation: str,
        is_from_ai: bool,
        selected_tense: tuple[str, str] | None = None,
    ) -> ExerciseTask:
        """Generate a tense exercise task.

        Args:
            word: Greek verb
            translation: Russian translation
            is_from_ai: Whether word is AI-generated
            selected_tense: Pre-selected tense tuple (greek, russian) or None for random

        Returns:
            ExerciseTask for tense practice
        """
        if selected_tense:
            tense_greek, tense_russian = selected_tense
        else:
            # Cards store verbs in present tense (Ενεστωτας), so exclude it
            # to avoid question = answer
            tenses = [
                ("Αοριστος", "прошедшее время (аорист)"),
                ("Μελλοντας", "будущее время"),
            ]
            tense_greek, tense_russian = random.choice(tenses)

        prompt = f"""For the Greek verb "{word}" ({translation}), provide the correct form in {tense_greek} (1st person singular).

Respond in JSON:
{{
    "correct_form": "the verb in requested tense"
}}"""

        try:
            response = await self.client.chat.completions.create(
                model=self.model,
                messages=[
                    {
                        "role": "system",
                        "content": "You are a Greek grammar expert. Provide accurate verb conjugations.",
                    },
                    {"role": "user", "content": prompt},
                ],
                max_tokens=50,
                temperature=0.2,
                response_format={"type": "json_object"},
            )

            content = response.choices[0].message.content or "{}"
            data = json.loads(content)
            expected_answer = data.get("correct_form", word)
        except (RateLimitError, APITimeoutError, APIConnectionError, APIError) as e:
            logger.error(f"Tense task generation API error: {e}")
            expected_answer = word
        except Exception as e:
            logger.exception(f"Unexpected error in tense task generation: {e}")
            expected_answer = word

        return ExerciseTask(
            word=word,
            translation=translation,
            task_text=f"Поставь глагол в {tense_russian}",
            task_hint=tense_greek,
            expected_answer=expected_answer,
            is_from_ai=is_from_ai,
        )

    async def _generate_conjugation_task(
        self,
        word: str,
        translation: str,
        is_from_ai: bool,
        selected_person: tuple[str, str, str] | None = None,
    ) -> ExerciseTask:
        """Generate a conjugation exercise task.

        Args:
            word: Greek verb
            translation: Russian translation
            is_from_ai: Whether word is AI-generated
            selected_person: Pre-selected person tuple (id, pronoun, russian) or None for random

        Returns:
            ExerciseTask for conjugation practice
        """
        if selected_person:
            person_id, pronoun, person_russian = selected_person
        else:
            # Cards store verbs in 1st person singular, so exclude it
            # to avoid question = answer
            persons = [
                ("2nd_singular", "εσυ", "2-е лицо ед.ч. (εσυ)"),
                ("3rd_singular", "αυτος", "3-е лицо ед.ч. (αυτος/η/ο)"),
                ("1st_plural", "εμεις", "1-е лицо мн.ч. (εμεις)"),
                ("2nd_plural", "εσεις", "2-е лицо мн.ч. (εσεις)"),
                ("3rd_plural", "αυτοι", "3-е лицо мн.ч. (αυτοι/ες/α)"),
            ]
            person_id, pronoun, person_russian = random.choice(persons)

        prompt = f"""For the Greek verb "{word}" ({translation}), provide the correct form for {person_id} ({pronoun}) in present tense.

Respond in JSON:
{{
    "correct_form": "the conjugated verb"
}}"""

        try:
            response = await self.client.chat.completions.create(
                model=self.model,
                messages=[
                    {
                        "role": "system",
                        "content": "You are a Greek grammar expert. Provide accurate verb conjugations.",
                    },
                    {"role": "user", "content": prompt},
                ],
                max_tokens=50,
                temperature=0.2,
                response_format={"type": "json_object"},
            )

            content = response.choices[0].message.content or "{}"
            data = json.loads(content)
            expected_answer = data.get("correct_form", word)
        except (RateLimitError, APITimeoutError, APIConnectionError, APIError) as e:
            logger.error(f"Conjugation task generation API error: {e}")
            expected_answer = word
        except Exception as e:
            logger.exception(f"Unexpected error in conjugation task generation: {e}")
            expected_answer = word

        return ExerciseTask(
            word=word,
            translation=translation,
            task_text=f"Спрягай для {person_russian}",
            task_hint=pronoun,
            expected_answer=expected_answer,
            is_from_ai=is_from_ai,
        )

    async def _generate_case_task(
        self,
        word: str,
        translation: str,
        is_from_ai: bool,
        selected_case: tuple[str, str] | None = None,
    ) -> ExerciseTask:
        """Generate a case exercise task.

        Args:
            word: Greek noun with article
            translation: Russian translation
            is_from_ai: Whether word is AI-generated
            selected_case: Pre-selected case tuple (greek, russian) or None for random

        Returns:
            ExerciseTask for case practice
        """
        if selected_case:
            case_greek, case_russian = selected_case
        else:
            # Cards store nouns in nominative case (Ονομαστικη), so exclude it
            # to avoid question = answer
            cases = [
                ("Γενικη", "родительный падеж (Γενικη)"),
                ("Αιτιατικη", "винительный падеж (Αιτιατικη)"),
                ("Κλητικη", "звательный падеж (Κλητικη)"),
            ]
            case_greek, case_russian = random.choice(cases)

        prompt = f"""For the Greek noun "{word}" ({translation}), provide the correct form in {case_greek} (singular, with article if applicable).

Respond in JSON:
{{
    "correct_form": "the noun in requested case with article"
}}"""

        try:
            response = await self.client.chat.completions.create(
                model=self.model,
                messages=[
                    {
                        "role": "system",
                        "content": (
                            "You are a Greek grammar expert. "
                            "Provide accurate noun declensions with articles."
                        ),
                    },
                    {"role": "user", "content": prompt},
                ],
                max_tokens=50,
                temperature=0.2,
                response_format={"type": "json_object"},
            )

            content = response.choices[0].message.content or "{}"
            data = json.loads(content)
            expected_answer = data.get("correct_form", word)
        except (RateLimitError, APITimeoutError, APIConnectionError, APIError) as e:
            logger.error(f"Case task generation API error: {e}")
            expected_answer = word
        except Exception as e:
            logger.exception(f"Unexpected error in case task generation: {e}")
            expected_answer = word

        return ExerciseTask(
            word=word,
            translation=translation,
            task_text=f"Поставь в {case_russian}",
            task_hint=case_greek,
            expected_answer=expected_answer,
            is_from_ai=is_from_ai,
        )

    async def verify_answer(
        self,
        task: ExerciseTask,
        user_answer: str,
        exercise_type: ExerciseType,
    ) -> AnswerResult:
        """Verify user's answer and provide feedback.

        Args:
            task: The exercise task
            user_answer: User's answer
            exercise_type: Type of exercise

        Returns:
            AnswerResult with correctness and feedback
        """
        prompt = f"""Evaluate the student's answer for a Greek grammar exercise.

Exercise type: {exercise_type.value}
Original word: {task.word} ({task.translation})
Task: {task.task_text} ({task.task_hint})
Expected answer: {task.expected_answer}
Student's answer: {user_answer}

Evaluate if the answer is correct. Consider minor spelling variations and accents.
Provide a brief grammar explanation in Russian.

Respond in JSON:
{{
    "is_correct": true/false,
    "feedback": "Explanation in Russian about the grammar rule and why the answer is correct/incorrect"
}}"""

        try:
            response = await self.client.chat.completions.create(
                model=self.model,
                messages=[
                    {
                        "role": "system",
                        "content": (
                            "You are a Greek language teacher evaluating student answers. "
                            "Be encouraging but accurate. Explain grammar rules simply. "
                            "Respond in Russian for the feedback. Always respond in valid JSON."
                        ),
                    },
                    {"role": "user", "content": prompt},
                ],
                max_tokens=300,
                temperature=0.3,
                response_format={"type": "json_object"},
            )

            content = response.choices[0].message.content or "{}"
            data = json.loads(content)

            return AnswerResult(
                is_correct=data.get("is_correct", False),
                feedback=data.get("feedback", ""),
                correct_answer=task.expected_answer,
            )
        except (RateLimitError, APITimeoutError, APIConnectionError, APIError) as e:
            logger.error(f"AI answer verification error: {e}")
            # Simple comparison fallback
            is_correct = user_answer.strip().lower() == task.expected_answer.strip().lower()
            return AnswerResult(
                is_correct=is_correct,
                feedback="Не удалось получить подробную обратную связь.",
                correct_answer=task.expected_answer,
            )
        except Exception as e:
            logger.exception(f"Unexpected error in answer verification: {e}")
            is_correct = user_answer.strip().lower() == task.expected_answer.strip().lower()
            return AnswerResult(
                is_correct=is_correct,
                feedback="Не удалось получить подробную обратную связь.",
                correct_answer=task.expected_answer,
            )
