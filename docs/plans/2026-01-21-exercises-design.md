# Design: Exercises Feature for Greek Grammar Practice

**Date:** 2026-01-21
**Status:** Implemented
**Author:** System Architect

## Overview

A new "Exercises" section for practicing Greek grammar through interactive exercises. Users can practice verb tenses, conjugations, and noun cases with AI-powered task generation and answer verification.

## Requirements Summary

| Requirement | Decision |
|-------------|----------|
| Exercise types | Tenses, Conjugations, Cases |
| Word source | Hybrid: user's cards first, then AI-generated |
| Session mode | Infinite (until user ends) |
| Difficulty selection | Random (AI chooses tense/person/case) |
| Answer verification | AI evaluates correctness |
| Feedback | AI explains grammar rules |
| Card integration | Offer to add AI words after session ends |

---

## Exercise Types

### 1. Tenses (Vremena)
- **Task:** Given a verb in infinitive/present, write it in the specified tense
- **Tenses:**
  - Enestotas (Present) - Ενεστωτας
  - Aoristos (Simple Past) - Αοριστος
  - Mellontas (Future) - Μελλοντας

**Example:**
```
Verb: γραφω (pishu)
Task: Postav v Αοριστος
Answer: εγραψα
```

### 2. Conjugations (Spryazheniya)
- **Task:** Given a verb in infinitive/present, write it for the specified person
- **Persons:**
  - 1st person singular (εγω)
  - 2nd person singular (εσυ)
  - 3rd person singular (αυτος/η/ο)
  - 1st person plural (εμεις)
  - 2nd person plural (εσεις)
  - 3rd person plural (αυτοι/ες/α)

**Example:**
```
Verb: γραφω (pishu)
Task: Spryagai dlya 2-go litsa mn.ch.
Answer: γραφετε
```

### 3. Cases (Padezhi)
- **Task:** Given a noun (with article), write it in the specified case
- **Cases:**
  - Ονομαστικη (Nominative)
  - Γενικη (Genitive)
  - Αιτιατικη (Accusative)
  - Κλητικη (Vocative)

**Example:**
```
Noun: ο ανθρωπος (chelovek)
Task: Postav v Γενικη
Answer: του ανθρωπου
```

---

## Layer-by-Layer Changes

### 1. States Layer

#### New File: `bot/telegram/states/exercise_states.py`

```python
"""FSM states for grammar exercises."""

from aiogram.fsm.state import State, StatesGroup


class ExerciseSession(StatesGroup):
    """States for exercise session."""

    waiting_for_answer = State()
```

**Notes:**
- Single state for waiting user's text answer
- Exercise type and current task stored in FSM data, not states

---

### 2. Services Layer

#### New File: `bot/services/exercise_service.py`

```python
"""Exercise service for grammar practice sessions."""

import json
import random
from dataclasses import dataclass
from enum import Enum

from openai import AsyncOpenAI
from sqlalchemy.ext.asyncio import AsyncSession

from bot.config.logging_config import get_logger
from bot.config.settings import settings
from bot.database.models.card import Card
from bot.database.repositories.card_repo import CardRepository
from bot.database.repositories.deck_repo import DeckRepository

logger = get_logger(__name__)


class ExerciseType(str, Enum):
    """Types of grammar exercises."""

    TENSES = "tenses"
    CONJUGATIONS = "conjugations"
    CASES = "cases"


@dataclass
class ExerciseTask:
    """A single exercise task."""

    word: str  # Greek word
    translation: str  # Russian translation
    task_text: str  # Task description in Russian
    task_hint: str  # Grammar hint (e.g., "Αοριστος")
    expected_answer: str  # Correct answer
    is_from_ai: bool  # Whether word was generated by AI


@dataclass
class AnswerResult:
    """Result of answer verification."""

    is_correct: bool
    feedback: str  # Grammar explanation in Russian
    correct_answer: str  # Show correct answer if wrong


class ExerciseService:
    """Service for grammar exercise sessions."""

    def __init__(self, session: AsyncSession):
        """Initialize exercise service.

        Args:
            session: Async database session
        """
        self.session = session
        self.card_repo = CardRepository(session)
        self.deck_repo = DeckRepository(session)
        self.client = AsyncOpenAI(
            api_key=settings.openai_api_key,
            timeout=settings.openai_timeout,
        )
        self.model = settings.openai_model

    async def get_user_words_for_exercise(
        self,
        user_id: int,
        exercise_type: ExerciseType,
        limit: int = 50,
    ) -> list[dict]:
        """Get words from user's cards suitable for the exercise type.

        Args:
            user_id: User ID
            exercise_type: Type of exercise
            limit: Maximum words to fetch

        Returns:
            List of dicts with 'word' and 'translation' keys
        """
        # Get all user's decks
        decks = await self.deck_repo.get_user_decks(user_id)
        if not decks:
            return []

        deck_ids = [deck.id for deck in decks]
        words = []

        # Collect words from cards
        for deck_id in deck_ids:
            cards = await self.card_repo.get_deck_cards(deck_id, limit=limit)
            for card in cards:
                # Filter by exercise type
                if exercise_type == ExerciseType.CASES:
                    # For cases, need nouns (words with articles)
                    if self._is_noun(card.front):
                        words.append({
                            "word": card.front,
                            "translation": card.back,
                        })
                else:
                    # For tenses/conjugations, need verbs
                    if self._is_verb(card.front):
                        words.append({
                            "word": card.front,
                            "translation": card.back,
                        })

        return words[:limit]

    def _is_noun(self, word: str) -> bool:
        """Check if word appears to be a noun (has article).

        Args:
            word: Greek word

        Returns:
            True if likely a noun
        """
        articles = ["ο ", "η ", "το ", "οι ", "τα "]
        word_lower = word.lower().strip()
        return any(word_lower.startswith(art) for art in articles)

    def _is_verb(self, word: str) -> bool:
        """Check if word appears to be a verb (ends in common verb endings).

        Args:
            word: Greek word

        Returns:
            True if likely a verb
        """
        # Verbs typically end in -ω, -ώ, -αω, -ιω, etc.
        verb_endings = ["ω", "ώ", "ει", "αι", "ουν", "ουμε"]
        word_stripped = word.strip()
        return any(word_stripped.endswith(ending) for ending in verb_endings)

    async def generate_task(
        self,
        exercise_type: ExerciseType,
        user_words: list[dict] | None = None,
    ) -> ExerciseTask:
        """Generate an exercise task.

        First tries to use user's words, falls back to AI generation.

        Args:
            exercise_type: Type of exercise
            user_words: Optional list of user's words

        Returns:
            ExerciseTask with task details
        """
        # Try to use user's word first
        if user_words:
            random.shuffle(user_words)
            word_data = user_words[0]
            is_from_ai = False
        else:
            # Generate word with AI
            word_data = await self._generate_word_with_ai(exercise_type)
            is_from_ai = True

        # Generate the specific task based on type
        task = await self._generate_task_details(
            exercise_type=exercise_type,
            word=word_data["word"],
            translation=word_data["translation"],
            is_from_ai=is_from_ai,
        )

        return task

    async def _generate_word_with_ai(
        self,
        exercise_type: ExerciseType,
    ) -> dict:
        """Generate a word using AI.

        Args:
            exercise_type: Type of exercise

        Returns:
            Dict with 'word' and 'translation'
        """
        if exercise_type == ExerciseType.CASES:
            word_type = "noun with definite article (o/η/το)"
            examples = "o ανθρωπος, η γυναικα, το παιδι"
        else:
            word_type = "common verb in present tense 1st person singular"
            examples = "γραφω, διαβαζω, τρωω, πινω"

        prompt = f"""Generate a random Greek {word_type} for a language learning exercise.

Requirements:
- Choose a common, frequently used word
- Suitable for A1-B1 learners
- Examples of format: {examples}

Respond in JSON format:
{{
    "word": "Greek word",
    "translation": "Russian translation"
}}"""

        response = await self.client.chat.completions.create(
            model=self.model,
            messages=[
                {
                    "role": "system",
                    "content": "You are a Greek language tutor. Generate words for exercises. Respond only in valid JSON.",
                },
                {"role": "user", "content": prompt},
            ],
            max_tokens=100,
            temperature=0.8,
            response_format={"type": "json_object"},
        )

        content = response.choices[0].message.content or "{}"
        data = json.loads(content)

        return {
            "word": data.get("word", "γραφω"),
            "translation": data.get("translation", "писать"),
        }

    async def _generate_task_details(
        self,
        exercise_type: ExerciseType,
        word: str,
        translation: str,
        is_from_ai: bool,
    ) -> ExerciseTask:
        """Generate task details including the expected answer.

        Args:
            exercise_type: Type of exercise
            word: Greek word
            translation: Russian translation
            is_from_ai: Whether word is AI-generated

        Returns:
            Complete ExerciseTask
        """
        if exercise_type == ExerciseType.TENSES:
            return await self._generate_tense_task(word, translation, is_from_ai)
        elif exercise_type == ExerciseType.CONJUGATIONS:
            return await self._generate_conjugation_task(word, translation, is_from_ai)
        else:  # CASES
            return await self._generate_case_task(word, translation, is_from_ai)

    async def _generate_tense_task(
        self,
        word: str,
        translation: str,
        is_from_ai: bool,
    ) -> ExerciseTask:
        """Generate a tense exercise task.

        Args:
            word: Greek verb
            translation: Russian translation
            is_from_ai: Whether word is AI-generated

        Returns:
            ExerciseTask for tense practice
        """
        tenses = [
            ("Ενεστωτας", "настоящее время"),
            ("Αοριστος", "прошедшее время (аорист)"),
            ("Μελλοντας", "будущее время"),
        ]
        tense_greek, tense_russian = random.choice(tenses)

        prompt = f"""For the Greek verb "{word}" ({translation}), provide the correct form in {tense_greek} (1st person singular).

Respond in JSON:
{{
    "correct_form": "the verb in requested tense"
}}"""

        response = await self.client.chat.completions.create(
            model=self.model,
            messages=[
                {
                    "role": "system",
                    "content": "You are a Greek grammar expert. Provide accurate verb conjugations.",
                },
                {"role": "user", "content": prompt},
            ],
            max_tokens=50,
            temperature=0.2,
            response_format={"type": "json_object"},
        )

        content = response.choices[0].message.content or "{}"
        data = json.loads(content)
        expected_answer = data.get("correct_form", word)

        return ExerciseTask(
            word=word,
            translation=translation,
            task_text=f"Поставь глагол в {tense_russian}",
            task_hint=tense_greek,
            expected_answer=expected_answer,
            is_from_ai=is_from_ai,
        )

    async def _generate_conjugation_task(
        self,
        word: str,
        translation: str,
        is_from_ai: bool,
    ) -> ExerciseTask:
        """Generate a conjugation exercise task.

        Args:
            word: Greek verb
            translation: Russian translation
            is_from_ai: Whether word is AI-generated

        Returns:
            ExerciseTask for conjugation practice
        """
        persons = [
            ("1st_singular", "εγω", "1-е лицо ед.ч. (εγω)"),
            ("2nd_singular", "εσυ", "2-е лицо ед.ч. (εσυ)"),
            ("3rd_singular", "αυτος", "3-е лицо ед.ч. (αυτος/η/ο)"),
            ("1st_plural", "εμεις", "1-е лицо мн.ч. (εμεις)"),
            ("2nd_plural", "εσεις", "2-е лицо мн.ч. (εσεις)"),
            ("3rd_plural", "αυτοι", "3-е лицо мн.ч. (αυτοι/ες/α)"),
        ]
        person_id, pronoun, person_russian = random.choice(persons)

        prompt = f"""For the Greek verb "{word}" ({translation}), provide the correct form for {person_id} ({pronoun}) in present tense.

Respond in JSON:
{{
    "correct_form": "the conjugated verb"
}}"""

        response = await self.client.chat.completions.create(
            model=self.model,
            messages=[
                {
                    "role": "system",
                    "content": "You are a Greek grammar expert. Provide accurate verb conjugations.",
                },
                {"role": "user", "content": prompt},
            ],
            max_tokens=50,
            temperature=0.2,
            response_format={"type": "json_object"},
        )

        content = response.choices[0].message.content or "{}"
        data = json.loads(content)
        expected_answer = data.get("correct_form", word)

        return ExerciseTask(
            word=word,
            translation=translation,
            task_text=f"Спрягай для {person_russian}",
            task_hint=pronoun,
            expected_answer=expected_answer,
            is_from_ai=is_from_ai,
        )

    async def _generate_case_task(
        self,
        word: str,
        translation: str,
        is_from_ai: bool,
    ) -> ExerciseTask:
        """Generate a case exercise task.

        Args:
            word: Greek noun with article
            translation: Russian translation
            is_from_ai: Whether word is AI-generated

        Returns:
            ExerciseTask for case practice
        """
        cases = [
            ("Ονομαστικη", "именительный падеж (Ονομαστικη)"),
            ("Γενικη", "родительный падеж (Γενικη)"),
            ("Αιτιατικη", "винительный падеж (Αιτιατικη)"),
            ("Κλητικη", "звательный падеж (Κλητικη)"),
        ]
        case_greek, case_russian = random.choice(cases)

        prompt = f"""For the Greek noun "{word}" ({translation}), provide the correct form in {case_greek} (singular, with article if applicable).

Respond in JSON:
{{
    "correct_form": "the noun in requested case with article"
}}"""

        response = await self.client.chat.completions.create(
            model=self.model,
            messages=[
                {
                    "role": "system",
                    "content": "You are a Greek grammar expert. Provide accurate noun declensions with articles.",
                },
                {"role": "user", "content": prompt},
            ],
            max_tokens=50,
            temperature=0.2,
            response_format={"type": "json_object"},
        )

        content = response.choices[0].message.content or "{}"
        data = json.loads(content)
        expected_answer = data.get("correct_form", word)

        return ExerciseTask(
            word=word,
            translation=translation,
            task_text=f"Поставь в {case_russian}",
            task_hint=case_greek,
            expected_answer=expected_answer,
            is_from_ai=is_from_ai,
        )

    async def verify_answer(
        self,
        task: ExerciseTask,
        user_answer: str,
        exercise_type: ExerciseType,
    ) -> AnswerResult:
        """Verify user's answer and provide feedback.

        Args:
            task: The exercise task
            user_answer: User's answer
            exercise_type: Type of exercise

        Returns:
            AnswerResult with correctness and feedback
        """
        prompt = f"""Evaluate the student's answer for a Greek grammar exercise.

Exercise type: {exercise_type.value}
Original word: {task.word} ({task.translation})
Task: {task.task_text} ({task.task_hint})
Expected answer: {task.expected_answer}
Student's answer: {user_answer}

Evaluate if the answer is correct. Consider minor spelling variations and accents.
Provide a brief grammar explanation in Russian.

Respond in JSON:
{{
    "is_correct": true/false,
    "feedback": "Explanation in Russian about the grammar rule and why the answer is correct/incorrect"
}}"""

        response = await self.client.chat.completions.create(
            model=self.model,
            messages=[
                {
                    "role": "system",
                    "content": (
                        "You are a Greek language teacher evaluating student answers. "
                        "Be encouraging but accurate. Explain grammar rules simply. "
                        "Respond in Russian for the feedback. Always respond in valid JSON."
                    ),
                },
                {"role": "user", "content": prompt},
            ],
            max_tokens=300,
            temperature=0.3,
            response_format={"type": "json_object"},
        )

        content = response.choices[0].message.content or "{}"
        data = json.loads(content)

        return AnswerResult(
            is_correct=data.get("is_correct", False),
            feedback=data.get("feedback", ""),
            correct_answer=task.expected_answer,
        )
```

**Service Methods Summary:**

| Method | Description |
|--------|-------------|
| `get_user_words_for_exercise` | Get suitable words from user's cards |
| `generate_task` | Generate exercise task (hybrid source) |
| `verify_answer` | Verify answer and provide grammar feedback |

---

### 3. Messages Layer

#### New File: `bot/messages/exercises.py`

```python
"""Exercise session messages in Russian."""

import html

# Main menu button
BTN_EXERCISES = "Упражнения"

# Exercise type selection
MSG_SELECT_EXERCISE_TYPE = (
    "<b>Грамматические упражнения</b>\n\n"
    "Выбери тип упражнения для практики:"
)

BTN_TENSES = "Времена глаголов"
BTN_CONJUGATIONS = "Спряжение глаголов"
BTN_CASES = "Падежи существительных"
BTN_BACK_TO_MENU = "Главное меню"

# Session start
MSG_SESSION_STARTED_TENSES = (
    "<b>Упражнения: Времена</b>\n\n"
    "Тебе будут даны глаголы. Напиши их в указанном времени.\n"
    "Нажми 'Завершить', чтобы закончить сессию."
)
MSG_SESSION_STARTED_CONJUGATIONS = (
    "<b>Упражнения: Спряжение</b>\n\n"
    "Тебе будут даны глаголы. Спрягай их для указанного лица.\n"
    "Нажми 'Завершить', чтобы закончить сессию."
)
MSG_SESSION_STARTED_CASES = (
    "<b>Упражнения: Падежи</b>\n\n"
    "Тебе будут даны существительные. Поставь их в указанный падеж.\n"
    "Нажми 'Завершить', чтобы закончить сессию."
)

# Task display
def get_task_message(
    word: str,
    translation: str,
    task_text: str,
    task_hint: str,
    total_count: int,
    correct_count: int,
) -> str:
    """Get task display message.

    Args:
        word: Greek word
        translation: Russian translation
        task_text: Task description
        task_hint: Grammar hint
        total_count: Total tasks answered
        correct_count: Correct answers count

    Returns:
        Task message
    """
    accuracy = (correct_count / total_count * 100) if total_count > 0 else 0
    stats = f"Выполнено: {total_count} | Правильно: {correct_count} ({accuracy:.0f}%)"

    return (
        f"<code>{stats}</code>\n\n"
        f"<b>Слово:</b> {html.escape(word)}\n"
        f"<b>Перевод:</b> {html.escape(translation)}\n\n"
        f"<b>Задание:</b> {html.escape(task_text)}\n"
        f"<code>{html.escape(task_hint)}</code>\n\n"
        f"Напиши ответ:"
    )


# Answer feedback
def get_correct_answer_message(feedback: str) -> str:
    """Get message for correct answer.

    Args:
        feedback: Grammar explanation

    Returns:
        Correct answer message
    """
    return f"<b>Правильно!</b>\n\n{html.escape(feedback)}"


def get_incorrect_answer_message(
    correct_answer: str,
    feedback: str,
) -> str:
    """Get message for incorrect answer.

    Args:
        correct_answer: The correct answer
        feedback: Grammar explanation

    Returns:
        Incorrect answer message
    """
    return (
        f"<b>Неправильно</b>\n\n"
        f"<b>Правильный ответ:</b> {html.escape(correct_answer)}\n\n"
        f"{html.escape(feedback)}"
    )


# Session end
BTN_END_SESSION = "Завершить"
BTN_NEXT_TASK = "Следующее"
BTN_SKIP_TASK = "Пропустить"

def get_session_complete_message(
    total_count: int,
    correct_count: int,
    ai_words_count: int,
) -> str:
    """Get session complete message.

    Args:
        total_count: Total tasks completed
        correct_count: Correct answers
        ai_words_count: Number of AI-generated words

    Returns:
        Session complete message
    """
    accuracy = (correct_count / total_count * 100) if total_count > 0 else 0

    text = (
        f"<b>Сессия завершена!</b>\n\n"
        f"<b>Выполнено упражнений:</b> {total_count}\n"
        f"<b>Правильных ответов:</b> {correct_count}\n"
        f"<b>Точность:</b> {accuracy:.1f}%\n\n"
    )

    if ai_words_count > 0:
        text += f"<b>Новых слов от AI:</b> {ai_words_count}\n\n"

    return text


MSG_SESSION_ENDED_EMPTY = "<b>Сессия завершена</b>\n\nУпражнения не выполнены."

# Add AI words to cards
MSG_OFFER_ADD_AI_WORDS = (
    "Хочешь добавить новые слова в карточки?\n"
    "Они были сгенерированы во время упражнений."
)
BTN_ADD_AI_WORDS = "Добавить слова в карточки"
BTN_SKIP_ADD_WORDS = "Пропустить"

MSG_WORDS_ADDED = "Слова добавлены в карточки!"
MSG_WORDS_SKIPPED = "Слова не добавлены."

# Exercise type labels (for callbacks)
EXERCISE_TYPE_LABELS = {
    "tenses": "Времена",
    "conjugations": "Спряжение",
    "cases": "Падежи",
}
```

---

### 4. Keyboards Layer

#### New File: `bot/telegram/keyboards/exercise_keyboards.py`

```python
"""Keyboards for grammar exercises."""

from aiogram.types import InlineKeyboardMarkup
from aiogram.utils.keyboard import InlineKeyboardBuilder

from bot.messages import exercises as ex_msg


def get_exercise_type_keyboard() -> InlineKeyboardMarkup:
    """Get keyboard with exercise type selection.

    Returns:
        Inline keyboard with exercise types
    """
    builder = InlineKeyboardBuilder()

    builder.button(text=ex_msg.BTN_TENSES, callback_data="exercise:tenses")
    builder.button(text=ex_msg.BTN_CONJUGATIONS, callback_data="exercise:conjugations")
    builder.button(text=ex_msg.BTN_CASES, callback_data="exercise:cases")
    builder.button(text=ex_msg.BTN_BACK_TO_MENU, callback_data="main_menu")

    builder.adjust(1)

    return builder.as_markup()


def get_task_keyboard() -> InlineKeyboardMarkup:
    """Get keyboard shown during task (while waiting for answer).

    Returns:
        Inline keyboard with skip/end options
    """
    builder = InlineKeyboardBuilder()

    builder.button(text=ex_msg.BTN_SKIP_TASK, callback_data="exercise:skip")
    builder.button(text=ex_msg.BTN_END_SESSION, callback_data="exercise:end")

    builder.adjust(2)

    return builder.as_markup()


def get_feedback_keyboard() -> InlineKeyboardMarkup:
    """Get keyboard shown after answer feedback.

    Returns:
        Inline keyboard with next/end options
    """
    builder = InlineKeyboardBuilder()

    builder.button(text=ex_msg.BTN_NEXT_TASK, callback_data="exercise:next")
    builder.button(text=ex_msg.BTN_END_SESSION, callback_data="exercise:end")

    builder.adjust(2)

    return builder.as_markup()


def get_session_end_keyboard(has_ai_words: bool = False) -> InlineKeyboardMarkup:
    """Get keyboard shown at session end.

    Args:
        has_ai_words: Whether there are AI words to add

    Returns:
        Inline keyboard with session end options
    """
    builder = InlineKeyboardBuilder()

    if has_ai_words:
        builder.button(text=ex_msg.BTN_ADD_AI_WORDS, callback_data="exercise:add_words")
        builder.button(text=ex_msg.BTN_SKIP_ADD_WORDS, callback_data="exercise:skip_words")
        builder.adjust(1)
    else:
        builder.button(text=ex_msg.BTN_EXERCISES, callback_data="exercises")
        builder.button(text=ex_msg.BTN_BACK_TO_MENU, callback_data="main_menu")
        builder.adjust(1)

    return builder.as_markup()


def get_after_add_words_keyboard() -> InlineKeyboardMarkup:
    """Get keyboard shown after adding words.

    Returns:
        Inline keyboard with navigation options
    """
    builder = InlineKeyboardBuilder()

    builder.button(text=ex_msg.BTN_EXERCISES, callback_data="exercises")
    builder.button(text=ex_msg.BTN_BACK_TO_MENU, callback_data="main_menu")

    builder.adjust(1)

    return builder.as_markup()
```

---

### 5. Handlers Layer

#### New File: `bot/telegram/handlers/exercises.py`

```python
"""Grammar exercise handlers."""

from aiogram import F, Router
from aiogram.fsm.context import FSMContext
from aiogram.types import CallbackQuery, Message
from sqlalchemy.ext.asyncio import AsyncSession

from bot.config.logging_config import get_logger
from bot.database.models.user import User
from bot.messages import common as common_msg
from bot.messages import exercises as ex_msg
from bot.services.card_service import CardService
from bot.services.deck_service import DeckService
from bot.services.exercise_service import ExerciseService, ExerciseType
from bot.telegram.keyboards.exercise_keyboards import (
    get_after_add_words_keyboard,
    get_exercise_type_keyboard,
    get_feedback_keyboard,
    get_session_end_keyboard,
    get_task_keyboard,
)
from bot.telegram.keyboards.main_menu import get_main_menu_keyboard
from bot.telegram.states.exercise_states import ExerciseSession

logger = get_logger(__name__)

router = Router(name="exercises")


@router.message(F.text == ex_msg.BTN_EXERCISES)
async def show_exercise_types(message: Message, state: FSMContext):
    """Show exercise type selection.

    Args:
        message: Message
        state: FSM state
    """
    await state.clear()
    await message.answer(
        ex_msg.MSG_SELECT_EXERCISE_TYPE,
        reply_markup=get_exercise_type_keyboard(),
    )


@router.callback_query(F.data == "exercises")
async def show_exercise_types_callback(callback: CallbackQuery, state: FSMContext):
    """Show exercise type selection from callback.

    Args:
        callback: Callback query
        state: FSM state
    """
    await state.clear()
    await callback.message.edit_text(
        ex_msg.MSG_SELECT_EXERCISE_TYPE,
        reply_markup=get_exercise_type_keyboard(),
    )
    await callback.answer()


@router.callback_query(F.data.startswith("exercise:") & F.data.in_([
    "exercise:tenses",
    "exercise:conjugations",
    "exercise:cases",
]))
async def start_exercise_session(
    callback: CallbackQuery,
    session: AsyncSession,
    state: FSMContext,
    user: User,
):
    """Start an exercise session of the selected type.

    Args:
        callback: Callback query
        session: Database session
        state: FSM state
        user: User instance
    """
    exercise_type_str = callback.data.split(":")[1]
    exercise_type = ExerciseType(exercise_type_str)

    # Show session start message
    start_messages = {
        ExerciseType.TENSES: ex_msg.MSG_SESSION_STARTED_TENSES,
        ExerciseType.CONJUGATIONS: ex_msg.MSG_SESSION_STARTED_CONJUGATIONS,
        ExerciseType.CASES: ex_msg.MSG_SESSION_STARTED_CASES,
    }

    # Get user's words for this exercise type
    exercise_service = ExerciseService(session)
    user_words = await exercise_service.get_user_words_for_exercise(
        user_id=user.id,
        exercise_type=exercise_type,
    )

    # Initialize session data
    await state.update_data(
        exercise_type=exercise_type_str,
        total_count=0,
        correct_count=0,
        ai_words=[],  # Will store AI-generated words for later adding
        user_words=user_words,  # Cache user's words
        current_task=None,
    )

    await callback.message.edit_text(start_messages[exercise_type])
    await callback.answer()

    # Generate and show first task
    await generate_and_show_task(callback, session, state, user)


async def generate_and_show_task(
    callback: CallbackQuery,
    session: AsyncSession,
    state: FSMContext,
    user: User,
):
    """Generate a new task and display it.

    Args:
        callback: Callback query
        session: Database session
        state: FSM state
        user: User instance
    """
    data = await state.get_data()
    exercise_type = ExerciseType(data.get("exercise_type"))
    user_words = data.get("user_words", [])
    total_count = data.get("total_count", 0)
    correct_count = data.get("correct_count", 0)

    exercise_service = ExerciseService(session)

    # Generate task
    task = await exercise_service.generate_task(
        exercise_type=exercise_type,
        user_words=user_words if user_words else None,
    )

    # Store current task in state
    await state.update_data(
        current_task={
            "word": task.word,
            "translation": task.translation,
            "task_text": task.task_text,
            "task_hint": task.task_hint,
            "expected_answer": task.expected_answer,
            "is_from_ai": task.is_from_ai,
        }
    )

    # Set state to wait for answer
    await state.set_state(ExerciseSession.waiting_for_answer)

    # Show task
    text = ex_msg.get_task_message(
        word=task.word,
        translation=task.translation,
        task_text=task.task_text,
        task_hint=task.task_hint,
        total_count=total_count,
        correct_count=correct_count,
    )

    await callback.message.answer(text, reply_markup=get_task_keyboard())


@router.message(ExerciseSession.waiting_for_answer)
async def process_answer(
    message: Message,
    session: AsyncSession,
    state: FSMContext,
    user: User,
):
    """Process user's answer to the exercise.

    Args:
        message: Message with user's answer
        session: Database session
        state: FSM state
        user: User instance
    """
    user_answer = message.text.strip()

    if not user_answer:
        await message.answer("Введи ответ или нажми 'Пропустить'.")
        return

    data = await state.get_data()
    current_task = data.get("current_task")
    exercise_type = ExerciseType(data.get("exercise_type"))

    if not current_task:
        await message.answer(common_msg.MSG_ERROR_GENERIC)
        await state.clear()
        return

    # Verify answer
    exercise_service = ExerciseService(session)

    from bot.services.exercise_service import ExerciseTask

    task = ExerciseTask(
        word=current_task["word"],
        translation=current_task["translation"],
        task_text=current_task["task_text"],
        task_hint=current_task["task_hint"],
        expected_answer=current_task["expected_answer"],
        is_from_ai=current_task["is_from_ai"],
    )

    result = await exercise_service.verify_answer(
        task=task,
        user_answer=user_answer,
        exercise_type=exercise_type,
    )

    # Update statistics
    total_count = data.get("total_count", 0) + 1
    correct_count = data.get("correct_count", 0)
    ai_words = data.get("ai_words", [])

    if result.is_correct:
        correct_count += 1

    # If word was from AI, add to list for later
    if current_task["is_from_ai"]:
        ai_words.append({
            "word": current_task["word"],
            "translation": current_task["translation"],
        })

    await state.update_data(
        total_count=total_count,
        correct_count=correct_count,
        ai_words=ai_words,
    )

    # Show feedback
    if result.is_correct:
        text = ex_msg.get_correct_answer_message(result.feedback)
    else:
        text = ex_msg.get_incorrect_answer_message(
            result.correct_answer,
            result.feedback,
        )

    await message.answer(text, reply_markup=get_feedback_keyboard())


@router.callback_query(F.data == "exercise:next")
async def next_task(
    callback: CallbackQuery,
    session: AsyncSession,
    state: FSMContext,
    user: User,
):
    """Generate and show next task.

    Args:
        callback: Callback query
        session: Database session
        state: FSM state
        user: User instance
    """
    await callback.message.delete()
    await generate_and_show_task(callback, session, state, user)
    await callback.answer()


@router.callback_query(F.data == "exercise:skip")
async def skip_task(
    callback: CallbackQuery,
    session: AsyncSession,
    state: FSMContext,
    user: User,
):
    """Skip current task and show next.

    Args:
        callback: Callback query
        session: Database session
        state: FSM state
        user: User instance
    """
    await callback.message.delete()
    await generate_and_show_task(callback, session, state, user)
    await callback.answer("Пропущено")


@router.callback_query(F.data == "exercise:end")
async def end_session(callback: CallbackQuery, state: FSMContext):
    """End the exercise session.

    Args:
        callback: Callback query
        state: FSM state
    """
    data = await state.get_data()
    total_count = data.get("total_count", 0)
    correct_count = data.get("correct_count", 0)
    ai_words = data.get("ai_words", [])

    # Clear the waiting state but keep data for potential word adding
    await state.set_state(None)

    if total_count == 0:
        await state.clear()
        await callback.message.edit_text(
            ex_msg.MSG_SESSION_ENDED_EMPTY,
            reply_markup=get_session_end_keyboard(has_ai_words=False),
        )
        await callback.answer()
        return

    text = ex_msg.get_session_complete_message(
        total_count=total_count,
        correct_count=correct_count,
        ai_words_count=len(ai_words),
    )

    has_ai_words = len(ai_words) > 0

    if has_ai_words:
        text += ex_msg.MSG_OFFER_ADD_AI_WORDS

    await callback.message.edit_text(
        text,
        reply_markup=get_session_end_keyboard(has_ai_words=has_ai_words),
    )
    await callback.answer()


@router.callback_query(F.data == "exercise:add_words")
async def add_ai_words_to_cards(
    callback: CallbackQuery,
    session: AsyncSession,
    state: FSMContext,
    user: User,
):
    """Add AI-generated words to user's cards.

    Args:
        callback: Callback query
        session: Database session
        state: FSM state
        user: User instance
    """
    data = await state.get_data()
    ai_words = data.get("ai_words", [])

    if not ai_words:
        await callback.answer("Нет слов для добавления.")
        await state.clear()
        return

    # Get or create a default deck for exercise words
    deck_service = DeckService(session)
    decks = await deck_service.get_user_decks(user.id)

    # Use first deck or create one
    if decks:
        deck = decks[0]
    else:
        deck = await deck_service.create_deck(
            user_id=user.id,
            name="Упражнения",
            description="Слова из упражнений",
        )

    # Add words as cards
    card_service = CardService(session)
    added_count = 0

    for word_data in ai_words:
        try:
            await card_service.create_card(
                deck_id=deck.id,
                front=word_data["word"],
                back=word_data["translation"],
            )
            added_count += 1
        except Exception as e:
            logger.warning(f"Failed to add card: {e}")

    await state.clear()

    await callback.message.edit_text(
        f"{ex_msg.MSG_WORDS_ADDED}\n\nДобавлено карточек: {added_count}",
        reply_markup=get_after_add_words_keyboard(),
    )
    await callback.answer()


@router.callback_query(F.data == "exercise:skip_words")
async def skip_add_words(callback: CallbackQuery, state: FSMContext):
    """Skip adding AI words to cards.

    Args:
        callback: Callback query
        state: FSM state
    """
    await state.clear()
    await callback.message.edit_text(
        ex_msg.MSG_WORDS_SKIPPED,
        reply_markup=get_after_add_words_keyboard(),
    )
    await callback.answer()
```

---

### 6. Main Menu Update

#### Modify: `bot/messages/common.py`

```python
# Add new button
BTN_EXERCISES = "Упражнения"
```

#### Modify: `bot/telegram/keyboards/main_menu.py`

```python
def get_main_menu_keyboard() -> ReplyKeyboardMarkup:
    """Get main menu keyboard.

    Returns:
        Reply keyboard with main menu options
    """
    builder = ReplyKeyboardBuilder()

    builder.button(text=msg.BTN_MY_DECKS)
    builder.button(text=msg.BTN_LEARN)
    builder.button(text=msg.BTN_EXERCISES)  # NEW
    builder.button(text=msg.BTN_ADD_CARD)
    builder.button(text=msg.BTN_STATISTICS)

    builder.adjust(2, 3)  # Updated layout

    return builder.as_markup(resize_keyboard=True)
```

---

### 7. Router Registration

#### Modify: `bot/telegram/bot.py`

```python
def setup_handlers(dp: Dispatcher) -> None:
    """Register all handlers."""
    from bot.telegram.handlers import (
        ai_chat,
        card_management,
        deck_management,
        errors,
        exercises,  # NEW
        learning,
        start,
        statistics,
        translation,
        unified_message,
    )

    dp.include_router(start.router)
    dp.include_router(deck_management.router)
    dp.include_router(card_management.router)
    dp.include_router(learning.router)
    dp.include_router(exercises.router)  # NEW - before translation/ai_chat
    dp.include_router(translation.router)
    dp.include_router(ai_chat.router)
    dp.include_router(unified_message.router)
    dp.include_router(statistics.router)
    dp.include_router(errors.router)

    logger.info("All handlers registered")
```

---

## AI Prompts (English for OpenAI)

### 1. Word Generation Prompt

```
For nouns:
Generate a random Greek noun with definite article (o/η/το) for a language learning exercise.
Requirements:
- Choose a common, frequently used word
- Suitable for A1-B1 learners
- Examples of format: o ανθρωπος, η γυναικα, το παιδι

For verbs:
Generate a random Greek common verb in present tense 1st person singular for a language learning exercise.
Requirements:
- Choose a common, frequently used word
- Suitable for A1-B1 learners
- Examples of format: γραφω, διαβαζω, τρωω, πινω

Response format:
{
    "word": "Greek word",
    "translation": "Russian translation"
}
```

### 2. Tense Task Generation Prompt

```
For the Greek verb "{word}" ({translation}), provide the correct form in {tense} (1st person singular).

Response format:
{
    "correct_form": "the verb in requested tense"
}
```

### 3. Conjugation Task Generation Prompt

```
For the Greek verb "{word}" ({translation}), provide the correct form for {person} ({pronoun}) in present tense.

Response format:
{
    "correct_form": "the conjugated verb"
}
```

### 4. Case Task Generation Prompt

```
For the Greek noun "{word}" ({translation}), provide the correct form in {case} (singular, with article if applicable).

Response format:
{
    "correct_form": "the noun in requested case with article"
}
```

### 5. Answer Verification Prompt

```
Evaluate the student's answer for a Greek grammar exercise.

Exercise type: {exercise_type}
Original word: {word} ({translation})
Task: {task_text} ({task_hint})
Expected answer: {expected_answer}
Student's answer: {user_answer}

Evaluate if the answer is correct. Consider minor spelling variations and accents.
Provide a brief grammar explanation in Russian.

Response format:
{
    "is_correct": true/false,
    "feedback": "Explanation in Russian about the grammar rule and why the answer is correct/incorrect"
}
```

---

## FSM State Data Structure

```python
{
    "exercise_type": "tenses",  # tenses | conjugations | cases
    "total_count": 0,  # Number of tasks answered
    "correct_count": 0,  # Number of correct answers
    "ai_words": [  # AI-generated words for potential card adding
        {"word": "γραφω", "translation": "писать"},
        ...
    ],
    "user_words": [  # Cached user's words from cards
        {"word": "ο ανθρωπος", "translation": "человек"},
        ...
    ],
    "current_task": {  # Current task being answered
        "word": "γραφω",
        "translation": "писать",
        "task_text": "Поставь в прошедшее время (аорист)",
        "task_hint": "Αοριστος",
        "expected_answer": "εγραψα",
        "is_from_ai": True,
    }
}
```

---

## Callback Data Format

| Action | Format | Example |
|--------|--------|---------|
| Show exercises menu | `exercises` | `exercises` |
| Start tenses | `exercise:tenses` | `exercise:tenses` |
| Start conjugations | `exercise:conjugations` | `exercise:conjugations` |
| Start cases | `exercise:cases` | `exercise:cases` |
| Next task | `exercise:next` | `exercise:next` |
| Skip task | `exercise:skip` | `exercise:skip` |
| Show answer | `exercise:show_answer` | `exercise:show_answer` |
| End session | `exercise:end` | `exercise:end` |
| Add AI words | `exercise:add_words` | `exercise:add_words` |
| Skip adding words | `exercise:skip_words` | `exercise:skip_words` |

---

## UI Flow Diagram

```
[Main Menu]
     |
     v
[BTN: "Упражнения"]
     |
     v
+---------------------------+
| Грамматические упражнения |
+---------------------------+
| [Времена глаголов]        |
| [Спряжение глаголов]      |
| [Падежи существительных]  |
| [Главное меню]            |
+---------------------------+
     |
     v (select type)
     |
+---------------------------+
| Session Start Message     |
+---------------------------+
     |
     v
+---------------------------+
| Выполнено: 0 | Правильно: 0|
|                           |
| Слово: γραφω              |
| Перевод: писать           |
|                           |
| Задание: Поставь в Αοριστος|
|                           |
| Напиши ответ:             |
+---------------------------+
| [Показать ответ] [Пропустить] |
| [Завершить]               |
+---------------------------+
     |
     v (user types answer)
     |
+---------------------------+
| Правильно!                |
| or                        |
| Неправильно               |
| Правильный ответ: εγραψα  |
|                           |
| Grammar explanation...    |
+---------------------------+
| [Следующее] [Завершить]   |
+---------------------------+
     |
     v (end session)
     |
+---------------------------+
| Сессия завершена!         |
| Выполнено: 10             |
| Правильно: 7              |
| Точность: 70%             |
|                           |
| Новых слов от AI: 3       |
| Хочешь добавить в карточки?|
+---------------------------+
| [Добавить слова]          |
| [Пропустить]              |
+---------------------------+
```

---

## Implementation Order

### Phase 1: Core Infrastructure
1. Create `bot/telegram/states/exercise_states.py`
2. Create `bot/messages/exercises.py`
3. Create `bot/telegram/keyboards/exercise_keyboards.py`

### Phase 2: Service Layer
4. Create `bot/services/exercise_service.py`
5. Add word filtering logic (is_noun, is_verb)
6. Add AI prompt methods

### Phase 3: Handler Layer
7. Create `bot/telegram/handlers/exercises.py`
8. Implement exercise type selection
9. Implement task generation flow
10. Implement answer verification
11. Implement session end flow
12. Implement AI words adding

### Phase 4: Integration
13. Update `bot/messages/common.py` (add BTN_EXERCISES)
14. Update `bot/telegram/keyboards/main_menu.py`
15. Update `bot/telegram/bot.py` (register router)

### Phase 5: Testing
16. Write unit tests for ExerciseService
17. Write unit tests for word filtering
18. Write integration tests for handlers
19. Test AI prompt responses

---

## Tests to Write

### `tests/test_services/test_exercise_service.py`

```python
class TestExerciseService:
    async def test_is_noun_with_article(self):
        """Test noun detection with article."""

    async def test_is_noun_without_article(self):
        """Test non-noun detection."""

    async def test_is_verb_with_verb_ending(self):
        """Test verb detection."""

    async def test_is_verb_with_non_verb(self):
        """Test non-verb detection."""

    async def test_get_user_words_for_tenses(self):
        """Test getting verbs from user cards."""

    async def test_get_user_words_for_cases(self):
        """Test getting nouns from user cards."""

    async def test_get_user_words_empty_decks(self):
        """Test with no user decks."""

    async def test_generate_task_uses_user_words_first(self):
        """Test hybrid word source prefers user words."""

    async def test_generate_task_falls_back_to_ai(self):
        """Test fallback to AI when no user words."""


class TestExerciseTaskGeneration:
    async def test_generate_tense_task(self):
        """Test tense task generation."""

    async def test_generate_conjugation_task(self):
        """Test conjugation task generation."""

    async def test_generate_case_task(self):
        """Test case task generation."""


class TestAnswerVerification:
    async def test_verify_correct_answer(self):
        """Test correct answer verification."""

    async def test_verify_incorrect_answer(self):
        """Test incorrect answer verification."""

    async def test_verify_with_accent_variation(self):
        """Test answer with accent differences."""
```

### `tests/conftest.py` Additions

```python
@pytest.fixture
def sample_verb_card_data():
    """Sample verb card data for testing."""
    return {
        "front": "γραφω",
        "back": "писать",
    }


@pytest.fixture
def sample_noun_card_data():
    """Sample noun card data for testing."""
    return {
        "front": "ο ανθρωπος",
        "back": "человек",
    }
```

---

## Error Handling

### AI Service Errors

```python
# In exercise_service.py, wrap AI calls with error handling:

try:
    response = await self.client.chat.completions.create(...)
except RateLimitError:
    logger.warning("OpenAI rate limit exceeded")
    # Return fallback task or error
except APITimeoutError:
    logger.error("OpenAI request timeout")
    # Return fallback task or error
except Exception as e:
    logger.exception(f"AI error: {e}")
    # Return fallback task or error
```

### Fallback Behavior

When AI fails:
- Use pre-defined fallback words/tasks
- Show user-friendly error message
- Allow retrying

---

## Edge Cases

1. **No user cards**: Generate all words with AI
2. **No suitable cards (all nouns for tense exercise)**: Fall back to AI
3. **AI returns invalid JSON**: Parse with fallback defaults
4. **User sends empty answer**: Prompt to enter answer or skip
5. **Session ends immediately**: Show empty session message
6. **AI verification uncertain**: Be lenient (accept close matches)

---

## Performance Considerations

1. **Cache user words**: Load once at session start, not per task
2. **Batch AI requests**: Consider pre-generating multiple tasks
3. **Limit card fetch**: Use limit parameter when fetching cards
4. **Timeout handling**: Set reasonable timeouts for AI calls

---

## Future Enhancements

1. **Difficulty levels**: Easy/Medium/Hard affecting tense/person/case selection
2. **Spaced repetition for exercises**: Track which grammar points need more practice
3. **Exercise statistics**: Track performance by exercise type over time
4. **Custom exercise sets**: Let users choose specific tenses/cases to practice
5. **Hints system**: Allow requesting hints before answering
6. **Audio pronunciation**: Add audio for correct answers
7. **Progress tracking**: Show improvement over time
8. **Leaderboards**: Compare with other learners

---

## Security Considerations

1. **Input sanitization**: Escape user input in messages
2. **Rate limiting**: Limit exercise sessions per user (AI cost)
3. **AI prompt injection**: Validate user answers before sending to AI
4. **State validation**: Verify state data integrity before processing

---

## Dependencies

No new dependencies required. Uses existing:
- `openai` - For AI task generation and verification
- `aiogram` - For Telegram bot functionality
- `sqlalchemy` - For database access

---

## Migration Notes

No database migrations required. Feature uses:
- Existing `Card` model for user words
- Existing `Deck` model for word sources
- FSM state for session data (no persistence needed)
